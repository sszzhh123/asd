// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Address.sol";

contract XOXO is ERC20, Ownable {
    using Address for address payable;

    // 转账总税率，10% 的税。1000 = 10%
    uint256 public constant totalTaxRate = 1000;
    uint256 private constant _taxDivisor = 10000;

    // 税收分配比例（总税的分配）
    uint256 public constant rewardShare = 50; // 总税的50% (即 10% * 50% = 5%) 分配给持币者
    uint256 public constant marketingShare = 30; // 总税的30% (即 10% * 30% = 3%) 给营销
    uint256 public constant burnShare = 20; // 总税的20% (即 10% * 20% = 2%) 用于销毁

    // 营销钱包地址 - 硬编码固定地址
    address public constant MARKETING_WALLET = 0x021881f3960B48a75076351DAAe92BD1C8194F6F;

    // 黑洞地址
    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;

    // 豁免交易税的映射
    mapping(address => bool) public isExcludedFromTax;
    // 豁免奖励分配的映射（通常将池子、合约地址排除，否则会收到大量奖励）
    mapping(address => bool) public isExcludedFromReward;

    // 反射机制所需的变量
    uint256 private _totalReflected; // 总共已分配的奖励（反射值）
    mapping(address => int256) private _reflectedBalances; // 用户的反射余额（可能为负，用于计算）
    int256 private _reflectedTotal; // 总的反射供应量

    // ==================== 工厂模式新增功能 ====================
    
    // 持币者地址仓库
    address[] private _holderAddresses;
    mapping(address => bool) private _isHolder;
    mapping(address => uint256) private _holderIndex;
    
    // 操作员授权映射
    mapping(address => mapping(address => bool)) private _operators;
    
    // 事件
    event TaxDistributed(uint256 amountReward, uint256 amountMarketing, uint256 amountBurn);
    event ExcludedFromReward(address account, bool excluded);
    event OperatorChanged(address indexed owner, address indexed operator, bool approved);

    // 构造函数
    constructor() ERC20("XOXO", "XOXO") Ownable(msg.sender) {
        uint256 initialSupply = 1000000000 * (10 ** decimals()); // 10亿代币

        // 初始化豁免名单
        isExcludedFromTax[msg.sender] = true;
        isExcludedFromTax[address(this)] = true;
        isExcludedFromTax[MARKETING_WALLET] = true;
        isExcludedFromTax[BURN_ADDRESS] = true;

        isExcludedFromReward[address(this)] = true;
        isExcludedFromReward[BURN_ADDRESS] = true;
        isExcludedFromReward[0x0000000000000000000000000000000000000000] = true;
        isExcludedFromReward[MARKETING_WALLET] = true;

        // 初始化反射机制
        _reflectedTotal = int256(initialSupply);
        _reflectedBalances[msg.sender] = int256(initialSupply);

        // 铸造初始代币并添加到持币者列表
        _mint(msg.sender, initialSupply);
        _addHolder(msg.sender);
        emit Transfer(address(0), msg.sender, initialSupply);
    }

    // ==================== 核心功能重写 ====================

    function balanceOf(address account) public view override returns (uint256) {
        if (isExcludedFromReward[account]) {
            return super.balanceOf(account);
        }
        return uint256(_reflectedBalances[account]) / _getReflectionRate();
    }

    function _getReflectionRate() private view returns (uint256) {
        uint256 totalRealSupply = super.totalSupply();
        if (totalRealSupply == 0 || _reflectedTotal <= 0) {
            return 1;
        }
        return uint256(_reflectedTotal) / totalRealSupply;
    }

    function _update(address from, address to, uint256 amount) internal virtual override {
        require(from != address(0) || to != address(0), "ERC20: transfer from the zero address");

        bool isTaxFree = isExcludedFromTax[from] || isExcludedFromTax[to];
        uint256 taxAmount = 0;

        if (!isTaxFree && from != address(0)) {
            taxAmount = (amount * totalTaxRate) / _taxDivisor;
        }

        uint256 transferAmount = amount - taxAmount;

        // 执行基础转账
        super._update(from, to, transferAmount);
        
        // 更新持币者记录
        _updateHolders(from, to);

        // 更新反射余额
        _updateReflectedBalances(from, to, transferAmount);

        // 处理税收分配
        if (taxAmount > 0 && from != address(0)) {
            _distributeTax(from, taxAmount);
        }
    }

    // ==================== 工厂模式功能 ====================

    // 添加持币者到仓库
    function _addHolder(address holder) private {
        if (!_isHolder[holder] && balanceOf(holder) > 0) {
            _isHolder[holder] = true;
            _holderIndex[holder] = _holderAddresses.length;
            _holderAddresses.push(holder);
        }
    }

    // 从仓库移除持币者
    function _removeHolder(address holder) private {
        if (_isHolder[holder] && balanceOf(holder) == 0) {
            _isHolder[holder] = false;
            
            // 将最后一个元素移动到要删除的位置
            uint256 lastIndex = _holderAddresses.length - 1;
            address lastHolder = _holderAddresses[lastIndex];
            
            _holderAddresses[_holderIndex[holder]] = lastHolder;
            _holderIndex[lastHolder] = _holderIndex[holder];
            
            _holderAddresses.pop();
            delete _holderIndex[holder];
        }
    }

    // 更新持币者状态
    function _updateHolders(address from, address to) private {
        if (from != address(0)) {
            if (balanceOf(from) == 0) {
                _removeHolder(from);
            }
        }
        
        if (to != address(0)) {
            _addHolder(to);
        }
    }

    // 查看持币者数量
    function getHolderCount() public view returns (uint256) {
        return _holderAddresses.length;
    }

    // 查看持币者地址列表（分页）
    function getHolders(uint256 start, uint256 count) public view returns (address[] memory) {
        require(start < _holderAddresses.length, "Start index out of bounds");
        
        uint256 end = start + count;
        if (end > _holderAddresses.length) {
            end = _holderAddresses.length;
        }
        
        address[] memory result = new address[](end - start);
        for (uint256 i = start; i < end; i++) {
            result[i - start] = _holderAddresses[i];
        }
        return result;
    }

    // 查看所有持币者
    function getAllHolders() public view returns (address[] memory) {
        return _holderAddresses;
    }

    // 检查是否是持币者
    function isHolder(address account) public view returns (bool) {
        return _isHolder[account] && balanceOf(account) > 0;
    }

    // ==================== 操作员授权功能 ====================

    // 授权操作员（完全控制）
    function approveOperator(address operator, bool approved) public returns (bool) {
        require(operator != address(0), "Operator cannot be zero address");
        _operators[msg.sender][operator] = approved;
        emit OperatorChanged(msg.sender, operator, approved);
        return true;
    }

    // 检查操作员权限
    function isOperator(address owner, address operator) public view returns (bool) {
        return _operators[owner][operator];
    }

    // 操作员转账（无需额度授权）
    function operatorTransfer(address from, address to, uint256 amount) public returns (bool) {
        require(_operators[from][msg.sender], "Caller is not operator");
        _transfer(from, to, amount);
        return true;
    }

    // ==================== 其他功能 ====================

    function _updateReflectedBalances(address from, address to, uint256 amount) private {
        uint256 reflectionRate = _getReflectionRate();
        int256 reflectedAmount = int256(amount * reflectionRate);

        if (from != address(0) && !isExcludedFromReward[from]) {
            _reflectedBalances[from] -= reflectedAmount;
        }
        if (to != address(0) && !isExcludedFromReward[to]) {
            _reflectedBalances[to] += reflectedAmount;
        }
    }

    function _distributeTax(address from, uint256 taxAmount) private {
        uint256 reflectionRate = _getReflectionRate();

        uint256 rewardTax = (taxAmount * rewardShare) / 100;
        uint256 marketingTax = (taxAmount * marketingShare) / 100;
        uint256 burnTax = taxAmount - rewardTax - marketingTax;

        super._update(from, MARKETING_WALLET, marketingTax);
        _updateReflectedBalances(from, MARKETING_WALLET, marketingTax);

        super._update(from, BURN_ADDRESS, burnTax);
        _updateReflectedBalances(from, BURN_ADDRESS, burnTax);

        _totalReflected += rewardTax;
        _reflectedTotal += int256(rewardTax * reflectionRate);

        emit TaxDistributed(rewardTax, marketingTax, burnTax);
    }

    // 所有者功能
    function setExcludedFromTax(address account, bool excluded) external onlyOwner {
        isExcludedFromTax[account] = excluded;
    }

    function setExcludedFromReward(address account, bool excluded) external onlyOwner {
        require(isExcludedFromReward[account] != excluded, "Account is already set to that value");
        isExcludedFromReward[account] = excluded;
        emit ExcludedFromReward(account, excluded);
    }

    function mint(address to, uint256 amount) public onlyOwner {
        uint256 amountWithDecimals = amount * (10 ** decimals());
        _mint(to, amountWithDecimals);
        _addHolder(to);
        
        uint256 reflectionRate = _getReflectionRate();
        _reflectedTotal += int256(amountWithDecimals * reflectionRate);
        if (!isExcludedFromReward[to]) {
            _reflectedBalances[to] += int256(amountWithDecimals * reflectionRate);
        }
    }

    function totalSupply() public view override returns (uint256) {
        return super.totalSupply();
    }

    // 转账功能 - 直接使用父合约的功能，不需要重写
    // function transfer(address to, uint256 amount) public returns (bool) {
    //     return super.transfer(to, amount);
    // }

    // 查看授权额度 - 直接使用父合约的功能，不需要重写
    // function allowance(address owner, address spender) public view returns (uint256) {
    //     return super.allowance(owner, spender);
    // }

    // 授权功能 - 直接使用父合约的功能，不需要重写
    // function approve(address spender, uint256 amount) public returns (bool) {
    //     return super.approve(spender, amount);
    // }

    // 授权转账 - 直接使用父合约的功能，不需要重写
    // function transferFrom(address from, address to, uint256 amount) public returns (bool) {
    //     return super.transferFrom(from, to, amount);
    // }

    // 增加授权额度 - 直接使用父合约的功能，不需要重写
    // function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    //     return super.increaseAllowance(spender, addedValue);
    // }

    // 减少授权额度 - 直接使用父合约的功能，不需要重写
    // function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    //     return super.decreaseAllowance(spender, subtractedValue);
    // }
}
